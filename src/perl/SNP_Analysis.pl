#! /usr/local/bin/perl

use strict;
use warnings;
use BSML::BsmlBuilder;

my $mumsAlignFile = $ARGV[0];
my $coverageFilePath = $ARGV[1];
my $outputBsmlFile = $ARGV[2];

# open the mummer alignment file (*.align)
# This file should be generated using the -D option
# which outputs only the difference positions and
# characters.

open( ALIGN, $mumsAlignFile ) or die "Unable to open $mumsAlignFile\n" ;

# create a Bsml document object to populate

my $bsmlDoc = new BSML::BsmlBuilder();

# Counters for Assembly and Reference sequence ids

my $assemblyId = 0;
my $assemblySNPCount = 0;
my $refSNPCount = 0;


while( my $line = <ALIGN> )
{
    if( $line =~ /^> ([\S]*)/ )
    {
	$assemblyId = $1;
	$assemblySNPCount = 0;

	
	# difficulties using the 'forward direction only' version of mummer
	# forces the use of bidirectional alignments. This filters the reverse
	# compliment alignments generated by mummer. Note a downstream process
	# has already reverse complimented sequences based on the tiling path
	# so Mummer's extra step is not necessary.

	if( $line =~ /^> $assemblyId Reverse/ )
	{
	    $assemblyId = 'SKIP';
	}

	next;
    }

    if( !($assemblyId eq 'SKIP') )
    {
	chomp( $line );
	my @mum = split( " ", $line );
    
	# Verify that the six columns have been populated 

	if( !( $mum[0] && $mum[1] && $mum[2] && $mum[3] && $mum[4] && $mum[5] ))
	    {
		next();
	    }

	### DOES NOT PROCESS GAPS (INSERTION/DELETION)
       
	if ($mum[4] =~ /-/ || $mum[5] =~ /-/){next;}

	### DOES NOT PROCESS AMBIGUOUS BP

	if ($mum[4] =~/[mrwsykn]/ || $mum[5] =~ /[mrwsykn]/) {next;}

	my $ref = $mum[0];
	$ref =~ s/Ref$//;

	my $refPos = $mum[2];
	my $asblPos = $mum[3];

	my $refBase = $mum[4];
	my $asblBase = $mum[5];

	my $revCom = 0;


	# Upstream process has tagged 'revcom' on assembly sequences whose tiling path
	# is on the reverse compliment. 

	if( $assemblyId =~ /revcom/ )
	{
	    $revCom = 1;
	}

	my $tmpAssemblyId = $assemblyId;

	# remove 'revcom' and 'ID' tags from assembly ids. The 'ID" substitution should 
	# be removed. Incoming fasta/BSML should encode the assembly identifiers necessary
	# to retrieve contigs and coverage data. 

	$tmpAssemblyId =~ s/revcom//;
	$tmpAssemblyId =~ s/ID//;

	# retrieve the coverage data associated with the SNP position. Should coverage on the 
	# reference also be looked up?

	my @cov = getCoverage( $tmpAssemblyId, $coverageFilePath, $asblPos, $revCom );

	# This will be removed after QC phase...

	#print "$ref $assemblyId $refPos $asblPos $refBase $asblBase | $cov[0] $cov[1] $cov[2]\n";

	# encode the SNP in BSML.

	my $refSeq;
	my $assemblySeq;

	if( !( $refSeq = $bsmlDoc->returnBsmlSequenceByIDR( "_$ref" ) ) )
	    {
		$refSeq = $bsmlDoc->createAndAddSequence( "_$ref", '', '', '' );
		$bsmlDoc->createAndAddFeatureTable( $refSeq );
	    }

	if( !( $assemblySeq = $bsmlDoc->returnBsmlSequenceByIDR( "_$tmpAssemblyId" ) ) )
	    {
		$assemblySeq = $bsmlDoc->createAndAddSequence( "_$tmpAssemblyId", '', '', '' );
		$bsmlDoc->createAndAddFeatureTable( $assemblySeq );
	    }

	my $refFTable = $refSeq->returnBsmlFeatureTableR( 0 );
	my $assemblyFTable = $assemblySeq->returnBsmlFeatureTableR( 0 );

	my $refFeat = $bsmlDoc->createAndAddFeatureWithLocN( 'FTable' => $refFTable,
							    'id' => "SNP:$ref:$refSNPCount",
							    'class' => 'SNP',
							    'start' => $refPos,
							    'end' => $refPos,
							    'complement' => 0
							    );
	
	$refFeat->addBsmlAttr( "COVERAGE", $cov[2] );
	$refFeat->addBsmlAttr( "CONSENSUS_SCORE", $cov[1] );
	$refFeat->addBsmlAttr( "SNP", "$refBase..$asblBase" );

	$refFeat->addBsmlLink( 'SNP', "SNP:$tmpAssemblyId:$assemblySNPCount" );

	my $assemblyFeat = $bsmlDoc->createAndAddFeatureWithLocN( 'FTable' => $assemblyFTable,
							    'id' => "SNP:$tmpAssemblyId:$assemblySNPCount",
							    'class' => 'SNP',
							    'start' => $asblPos,
							    'end' => $asblPos,
							    'complement' => $revCom
							    );
	
	$assemblyFeat->addBsmlAttr( "COVERAGE", $cov[2] );
	$assemblyFeat->addBsmlAttr( "CONSENSUS_SCORE", $cov[1] );
	$assemblyFeat->addBsmlAttr( "SNP", "$asblBase..$refBase"  );

	$assemblyFeat->addBsmlLink( 'SNP', "SNP:$ref:$refSNPCount" );

	$assemblySNPCount++;
	$refSNPCount++;
    }
}

$bsmlDoc->write( $ARGV[2] );

sub getCoverage
{
    my $assemblyId = shift;
    my $coverAgePrefix = shift;
    my $pos = shift;
    my $revCom = shift;

    open( TCOV, "$coverAgePrefix/$assemblyId.tcov" ) or die "Could not open $coverAgePrefix/$assemblyId\n";


    my $count = 0;
    my @tcov;

    while( my $line = <TCOV> )
    {
	if( $line =~ /([\d]*) ([\S]) ([\d]*) ([\S]*) ([\d:]*) ([\d:]*)/ )
	{
	    chomp $line;
	    $tcov[$count] = $line;
	    $count++;
	}
    }

    if( $revCom == 1 )
    {
	$pos = @tcov - $pos + 1; 
    }

    my @coverageDat = split( ' ', $tcov[$pos-1] );

    my $snpPos = $coverageDat[0];
    my $qual = $coverageDat[2];
    
    my @seqIdList = split( ':', $coverageDat[5] );

    my $coverage = @seqIdList;

    close( TCOV );

    return ($snpPos, $qual, $coverage );
}
