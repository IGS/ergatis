#!/usr/local/packages/perl-5.8.5/bin/perl

BEGIN{foreach (@INC) {s/\/usr\/local\/packages/\/local\/platform/}};
use lib (@INC,$ENV{"PERL_MOD_DIR"});
no lib "$ENV{PERL_MOD_DIR}/i686-linux";
no lib ".";

=head1  NAME 

hmmpfam2bsml.pl - convert hmmpfam raw output to BSML

=head1 SYNOPSIS

USAGE: hmmpfam2bsml.pl 
        --input=/path/to/somefile.hmmpfam.raw 
        --output=/path/to/somefile.hmmpfam.bsml
      [ --search_method=hmmpfam
        --log=/path/to/some.log
        --debug=4 
        --help
      ]

=head1 OPTIONS

B<--input,-i> 
    Input raw alignment file from an hmmpfam search.

B<--output,-o> 
    Output BSML file

B<--search_method,-m> 
    Optional. Search method used with hmmpfam.  default is 'hmmpfam' but others
    include 'hmmsmart', 'hmmpir', etc.

B<--debug,-d> 
    Debug level.  Use a large number to turn on verbose debugging. 

B<--log,-l> 
    Log file

B<--help,-h> 
    This help message

=head1   DESCRIPTION

This script is used to convert the raw alignment output from an hmmpfam search into BSML.

=head1 INPUT

The input file passed to this script must be a raw alignment file generated by hmmpfam.
Define the input file using the --input option.

Illegal characters will be removed from the IDs for the query sequence and subject hit
if necessary to create legal XML id names.  For each element, the original, unmodified 
name will be stored in the "title" attribute of the Sequence element.  You should make 
sure that your ids don't begin with a number.  This script will successfully create a 
BSML document regardless of your ID names, but the resulting document may not pass DTD 
validation.

=head1 OUTPUT

The BSML file to be created is defined using the --output option.  If the file already exists
it will be overwritten.

Because the hmmpfam executable is used to perform a variety of searches, including hmmsmart
and hmmtigr, the user may pass a value using --search_method, which will create the
appropriate titles in the BSML Analysis element.  If not passed, the default 'hmmpfam' is used.

=head1 CONTACT

    Joshua Orvis
    jorvis@tigr.org

=cut

use strict;
use Getopt::Long qw(:config no_ignore_case no_auto_abbrev);
use Pod::Usage;
use Workflow::Logger;
use BSML::BsmlRepository;
use BSML::BsmlBuilder;
use BSML::BsmlParserTwig;

my %options = ();
my $results = GetOptions (\%options, 
              'input|i=s',
              'output|o=s',
              'search_method|m=s',
              'log|l=s',
              'debug=s',
              'help|h') || pod2usage();

my $logfile = $options{'log'} || Workflow::Logger::get_default_logfilename();
my $logger = new Workflow::Logger('LOG_FILE'=>$logfile,
                  'LOG_LEVEL'=>$options{'debug'});
$logger = $logger->get_logger();

# display documentation
if( $options{'help'} ){
    pod2usage( {-exitval=>0, -verbose => 2, -output => \*STDOUT} );
}

## make sure all passed options are peachy
&check_parameters(\%options);

## we want a new doc
my $doc = new BSML::BsmlBuilder();

## open the input file for parsing
open (my $ifh, $options{'input'}) || $logger->logdie("can't open input file for reading");

## go through the top of the file and get a few things.
my ($hmm_file, $sequence_file, $qry_id);
while (<$ifh>) {
    if (/HMM file\:\s+(\S+)/) {
        $hmm_file = $1;
    } elsif (/Sequence file\:\s+(\S+)/) {
        $sequence_file = $1;
    } elsif (/Query sequence\: (\S+)/) {
        $qry_id = $1;
    }

    ## quit once we hit the overall scores section
    last if (/Scores for sequence family classification/i);
}

## the query sequence only counts up the first whitespace
if ($qry_id =~ /(.+?)\s+/) {
    $qry_id = $1;
}

## make sure the name is legal
my $qry_id_orig = $qry_id;
$qry_id =~ s/[^a-zA-Z0-9\.\-\_]/_/g;

## make sure we found all 3
unless ($hmm_file)      { $logger->logdie("HMM file definition not found in input file.") }
unless ($sequence_file) { $logger->logdie("Sequence file definition not found in input file.") }
unless ($qry_id)        { $logger->logdie("Query sequence definition not found in input file.") }

## add the query sequence file to the doc
##  the use of 'aa' is not guaranteed here, but we're not using it anyway in loading
my $seq = $doc->createAndAddSequence($qry_id, $qry_id_orig, undef, 'aa', 'polypeptide');
   $seq->addBsmlLink('analysis', "\#$options{search_method}_analysis", 'input_of');

## for each model matched, create a Seq-pair-alignment and record the overall score and
## overall E-value
my %alignments;
my ($model, $description, $score, $eval);
while (<$ifh>) {
    ## datalines here look like this:
    # PF00933   Glyco_hydro_3: Glycosyl hydrolase family 3    320.7      3e-93   1
    # PF01915   Glyco_hydro_3_C: Glycosyl hydrolase family    152.2    1.7e-42   1
    # PF07691   PA14: PA14 domain                              25.5    0.00022   1
    # TIGR02148 Fibro_Slime: fibro-slime domain               -33.6        1.1   1
    # PF02014   Reeler: Reeler domain                         -46.3        5.9   1
    # PF06325   PrmA: ribosomal protein L11 methyltransfera  -198.1        8.5   1
    if (/^(\S+)\s+(.+?)\s+([0-9\.\-e]+)\s+([0-9\.\-e]+)\s+\d+\s*$/) {
        ($model, $description, $score, $eval) = ($1, $2, $3, $4);

        ## add this model sequence
        my $seq = $doc->createAndAddSequence($model, $description, undef, 'aa', 'polypeptide');
		#$seq->addBsmlLink('analysis', "\#$options{search_method}_analysis", 'input_of');
        
        $alignments{$model} = $doc->createAndAddSequencePairAlignment( refseq => $qry_id,
                                                                       refstart => 0,
                                                                       #refend => $cols[2] - 1,
                                                                       #reflength => $cols[2],
                                                                       compseq => $model,
                                                                     );
        ## add a link element inside this seq-pair-alignment
        $alignments{$model}->addBsmlLink('analysis', "\#$options{search_method}_analysis", 'computed_by');
        
        ## add the total_score and total_eval for this pair
        $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_score', $score);
        $doc->createAndAddBsmlAttribute($alignments{$model}, 'total_e_value',  $eval);
    }

    ## quit once we hit domain section
    last if (/Parsed for domains/);
}


## we should now be in the region where the domain hits are described.  We'll add Seq-pair-runs
##  to each of our Seq-pair-alignments here
my $linectr=0;

while (<$ifh>) {
    chomp;

    ## these rows should look like this:
    # PF00933     1/1      39   254 ..     1   243 []   320.7    3e-93
    # PF01915     1/1     331   702 ..     1   308 []   152.2  1.7e-42
    # PF02014     1/1     345   465 ..     1   150 []   -46.3      5.9
    # PF07691     1/1     406   539 ..     1   178 []    25.5  0.00022
    # TIGR02148   1/1     432   525 ..     1    92 []   -33.6      1.1
    # PF06325     1/1     449   682 ..     1   312 []  -198.1      8.5
    my ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval);
    if (/^(\S+)\s+([0-9]+)\/([0-9]+)\s+(\d+)\s+(\d+).+(\d+)\s+(\d+).+?([0-9\-][0-9\.\-e]+)\s+([0-9\.\-e\+]+)\s*$/) {

        $linectr++;

        ($model, $domain_num, $domain_of, $qry_start, $qry_stop, $sbj_start, $sbj_stop, $score, $eval) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);
        
        my $run = $doc->createAndAddSequencePairRun(   alignment_pair => $alignments{$model},
                                                       runscore => $score,
                                                       runlength => abs($qry_stop - $qry_start) + 1,
                                                       comprunlength => abs($sbj_stop - $sbj_start) + 1,
                                                       refpos => min($qry_start, $qry_stop) - 1,
                                                       refcomplement => 0,
                                                       comppos => min($sbj_start, $sbj_stop) - 1,
                                                       compcomplement => 0
                                                   );
        ## add other attributes of the run
        $doc->createAndAddBsmlAttributes($run, 
                                            e_value    => $eval,
                                            domain_num => $domain_num,
                                            domain_of  => $domain_of
                                        );

    } else {

        ## Skip the headers and blank lines
        next if (/^Model\s+Domain\s+/i);
        next if (/^--------\s+-------\s+-----\s+-----\s+-----\s+-----\s+-----\s+-------/);
        next if (/^\s*$/);
        
        ## do nothing if no matches were found
        next if (/no hits above thresholds/);
        
        last if (/Alignments of top-scoring domains/);
        die "Could not parse line number '$linectr': '$_'";
    }
    ## quit once we've read the alignments section
    last if (/Alignments of top-scoring domains/);
}



## add the analysis element
$doc->createAndAddAnalysis(
                            id => "$options{search_method}_analysis",
                            sourcename => $options{'output'},
                          );

## now write the doc
$doc->write($options{'output'});

exit;


sub check_parameters {
    
    ## make sure input file exists
    if (! -e $options{'input'}) { $logger->logdie("input file $options{'input'} does not exist") }

    ## make user an output file was passed
    if (! $options{'output'}) { $logger->logdie("output option required!") }

    ## handle defaults
    $options{'search_method'} = 'hmmpfam' unless ( $options{'search_method'} );

    return 1;
}

sub min {
    my ($num1, $num2) = @_;
    
    if ($num1 < $num2) {
        return $num1;
    } else {
        return $num2;
    }
}
