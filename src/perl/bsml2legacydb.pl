#!/usr/local/bin/perl -w

=head1	NAME

bsm2legacydb.pl - load WorkFlow BSML files into the legacy database

=head1	SYNOPSIS

USAGE: bsml2legacydb.pl
		--input_file|i=/path/to/bsml_data.bsml
		--input_list|I=/path/to/bsml_file_list
		--database=aa1
	[
		--debug=4
		--log=/path/to/log_file.log
	]

=head1	OPTIONS

B<--input_file,-i>
	Location of bsml input file

B<--input_list,-I>
	Location of bsml input list

B<--database,-d>
	Database where data will be loaded to

B<--debug,-D>
	Debug level.  Use a large number to turn on verbose debugging

B<--log,-l>
	Log file

B<--help,-h>
	Print help

=head1	DESCRIPTION

This script will load the WorkFlow BSML files into the legacy database

=head1	INPUT

The input is a BSML file.  It will handle BSML data from augustus, genie,
genezilla, gap2, and nap.

The name of each assembly is pulled from the BSML file names processed,
which should be of the format:

	[data_type].assembly.[assembly_id].[program_name].bsml

=head1	OUTPUT

No output file is generated unless a LOG is passed.  There are many warning
messages sent to stderr (in case of gene prediction loading) which come
from the libraries used (not generated by this code)

=head1	CONTACT

Ed Lee (elee@tigr.org)

=cut

use strict;
use Getopt::Long qw(:config no_ignore_case pass_through);
use Pod::Usage;
use Workflow::Logger;
use DBI;
use XML::Twig;
use IO::File;
use lib '/usr/local/devel/ANNOTATION/Euk_modules/bin';
use Gene_obj;
use Annot_prediction_loader;

my @files	= ();
my $server	= "SYBTIGR";
my $db		= 0;
my $user	= 0;
my $pass	= 0;
my %opts	= ();
my %coords	= ();
my @genes	= ();
my %db_ids	= ();
my $debug	= 4;
my $log_file	= Workflow::Logger::get_default_logfilename;
my $logger	= 0;

sub print_usage;
sub parse_opts;
sub process_files;
sub process_feat;
sub process_feat_group;
sub process_aln;
sub get_db_id;
sub fetch_db_id;
sub insert_db_id;
sub swap;
sub prepare_insert_stmt;

GetOptions(\%opts, "input_file|i=s", "input_list|I=s",
	   "server|s=s", "db|d=s", "user|u=s", "pass|p=s",
	   "debug|D=i", "log|l=s", "help|h");
parse_opts;

my $dbh = DBI->connect("dbi:Sybase:$server", $user, $pass, 
		       {AutoCommit => 0, RaiseError => 1, PrintError => 1}) or
	die "Error accessing db: DBI::errstr";
$dbh->do("use $db");

process_files;
$dbh->commit if !$dbh->{AutoCommit};
$dbh->disconnect;

sub parse_opts
{
	while (my ($key, $val) = each (%opts)) {
		if ($key eq "input_file") {
			push @files, $val;
		}
		elsif ($key eq "input_list") {
			my $fh = new IO::File($val) or
				die "Error accessing input list " .
				    "$opts{input_list}: $!";
			while (my $file = <$fh>) {
				chomp $file;
				next if $file =~ /^\s*$/;
				push @files, $file;
			}
		}
		elsif ($key eq "server") {
			$server = $val;
		}
		elsif ($key eq "db") {
			$db = $val;
		}
		elsif ($key eq "user") {
			$user = $val;
		}
		elsif ($key eq "pass") {
			$pass = $val;
		}
		elsif ($key eq "debug") {
			$debug = $val;
		}
		elsif ($key eq "log") {
			$log_file = $val;
		}
		elsif ($key eq "help") {
			print_usage if $val;
		}
	}
	$logger = new Workflow::Logger('LOG_FILE' => $log_file,
				       'LOG_LEVEL' => $debug);
	$logger = Workflow::Logger::get_logger;
	$logger->logdie("No input(s) provided") if !scalar(@files);
	$logger->logdie("No database provided") if !$db;
	$logger->logdie("No username provided") if !$user;
	$logger->logdie("No password provided") if !$pass;
}

sub print_usage
{
	pod2usage( {-exitval => 1, -verbose => 2, -output => \*STDERR} );
}

sub process_files
{
	foreach my $file (@files) {
		$logger->debug("Processing $file") if $logger->is_debug;
		my $asm_id = $1 if $file =~ /\.assembly\.(\d+)/ or
			$logger->logdie("Couldn't extract assembly id from: " .
					"$file");
		my $prog_name = $1 if $file =~ /(\w+)\.bsml/ or
			$logger->logdie("Couldn't extract program name from: " .
					"$file");
		my $twig = new XML::Twig
			(twig_roots =>
				{'Feature' => \&process_feat,
				 'Feature-group' => \&process_feat_group,
				 'Seq-pair-alignment' => sub {
					my ($twig, $aln) = @_;
					process_aln($twig, $aln,
						    $asm_id, $prog_name);
					}});
		$twig->parsefile($file);
		if (scalar(@genes)) {
			process_results($asm_id, $prog_name);
		}
	}
}

sub process_results
{
	my ($asm_id, $prog_name) = @_;
	$prog_name = 'GeneZilla' if $prog_name =~ /genezilla/;
	my $loader = new Annot_prediction_loader($dbh, $asm_id, $prog_name);
	$loader->load_predictions(@genes);
}

sub process_feat
{
	my ($twig, $feat) = @_;
	my $id = $feat->att('id') or
		$logger->logdie("Feature found with no id");
	if ($feat->att('class') eq 'exon') {
		my $seq_int = $feat->first_child('Interval-loc') or
			$logger->logdie("Feature $id has no Interval-loc");
		$logger->logdie("Feature $id missing seq positions") if
			!defined $seq_int->att('startpos') or
			!defined $seq_int->att('endpos');
		my ($start_pos, $end_pos) = ($seq_int->att('startpos') + 1,
			$seq_int->att('endpos') + 1);
		$logger->logdie("Feature $id has invalid complement value")
			if ($seq_int->att('complement') != 0 and
			$seq_int->att('complement') != 1);
		swap(\$start_pos, \$end_pos) if ($seq_int->att('complement'));
		push @{$coords{$id}}, $start_pos, $end_pos;
	}
	else {
		$logger->debug("Skipping feature $id [class is not exon]")
			if $logger->is_debug;
	}
	$twig->purge;
}

sub process_feat_group
{
	my ($twig, $feat_group) = @_;
	my %exon_coords = ();
	foreach my $child ($feat_group->children('Feature-group-member')) {
		if ($child->att('feature-type') eq 'exon') {
			my $id = $child->att('featref') or
				$logger->logdie("Feature-group-member has no " .
						"featref");
			$exon_coords{$coords{$id}->[0]} = $coords{$id}->[1];
		}
	}
	if (scalar keys %exon_coords) {
		my $gene = new Gene_obj;
		$gene->populate_gene_obj(\%exon_coords, \%exon_coords);
		push @genes, $gene;
	}
	else {
		$logger->warn("Skipping feature group " .
			      $feat_group->att('group_set') .
			      " because it has no exons") if $logger->is_warn;
	}
	$twig->purge;
}

sub process_aln
{
	my ($twig, $aln, $asm_id, $prog_name) = @_;
	my $total_score = 0;
	foreach my $attr ($aln->children('Attribute')) {
		$total_score = $attr->att('content') and last
			if ($attr->att('name') eq 'total_score') or
			$logger->logdie("Failed to get total_score from " .
					"Seq-pair-alignment");
	}
	my $subj_id = $aln->att('compseq') or
		$logger->logdie("Cannot find compseq for Seq-pair-alignment");
	my $db_name = $1 if $aln->att('compxref') =~ /\/([\w\.]+):/ or
		$logger->logdie("Cannot extract compxref from " .
				"Seq-pair-alignment");
	my $db_id = get_db_id($db_name);
	my $chain_num = 0;
	my $pct_id = 0;
	my $pct_sim = 0;
	foreach my $seq_pair_run ($aln->children('Seq-pair-run')) {
		my $score = $seq_pair_run->att('runscore');
		my $query_start = $seq_pair_run->att('refpos') + 1;
		my $query_aln_len = $seq_pair_run->att('runlength');
		my $query_stop = $query_start + $query_aln_len;
		my $query_comp = $seq_pair_run->att('refcomplement');
		my $subj_start = $seq_pair_run->att('comppos') + 1;
		my $subj_aln_len = $seq_pair_run->att('comprunlength');
		my $subj_stop = $subj_start + $subj_aln_len;
		my $subj_comp = $seq_pair_run->att('compcomplement');
		swap(\$query_start, \$query_stop) if $query_comp;
		swap(\$subj_start, \$subj_stop) if $subj_comp;
		foreach my $attr ($seq_pair_run->children('Attribute')) {
			if ($attr->att('name') eq 'chain_number') {
				$chain_num = $attr->att('content')
					if !$chain_num;
			}
			elsif ($attr->att('name') eq 'percent_identity') {
				$pct_id = $attr->att('content');
			}
			elsif ($attr->att('name') eq 'percent_similarity') {
				$pct_sim = $attr->att('content');
			}
		}
		$logger->logdie("Failed to extract either chain_number, " .
				"percent_identity, or percent_similarity ".
				"from Seq-pair_run")
			if !$chain_num or !$pct_id or !$pct_sim;
		my $prog_tag = $prog_name eq 'aat_aa' ? 'nap' : 'gap2';
		my $insert_stmt = prepare_insert_stmt;
		$insert_stmt->execute("$asm_id.intergenic", $prog_tag, 
				      $subj_id, $query_start, $query_stop,
				      $subj_start, $subj_stop, $prog_name,
				      $pct_id, $pct_sim, $score, $db_id,
				      $score, $total_score, $chain_num);
	}
	$twig->purge;
}

sub get_db_id
{
	my $db_name = shift;
	return $db_ids{$db_name} if exists $db_ids{$db_name};
	my $db_id = fetch_db_id($db_name);
	if (!$db_id) {
		$db_id = insert_db_id($db_name);
		$logger->debug("Got new search_dbs id $db_id for $db_name")
			if $logger->is_debug;
	}
	else {
		$logger->debug("Got existing search_dbs id $db_id for $db_name")
			if $logger->is_debug;
	}
	$logger->logdie("Failed to get search_dbs ID for database $db_name")
		if !$db_id;
	$db_ids{$db_name} = $db_id;
	return $db_id;
}

sub fetch_db_id
{
	my $db_name = shift;
	my $sql = "SELECT id FROM common..search_dbs WHERE name='$db_name'";
	my $stmt = $dbh->prepare($sql);
	$stmt->execute;
	my $db_id = $stmt->fetchrow_arrayref->[0] or 0;
	$stmt->finish;
	return $db_id;
}

sub insert_db_id
{
	my $db_name = shift;
	my $sql = "INSERT INTO common..search_dbs (name, " .
		  "release_notes, date, assignby, iscurrent, type) " .
		  "VALUES ('$db_name', NULL, getdate(), 'workflow', 1, " .
		  "'custom')";
	my $stmt = $dbh->prepare($sql);
	$stmt->do($sql);
	return fetch_db_id($db_name);
}

sub swap
{
	my ($val1, $val2) = @_;
	($$val1, $$val2) = ($$val2, $$val1);
}

sub prepare_insert_stmt
{
	my $sql = "INSERT INTO evidence (feat_name, ev_type, accession, " .
		  "end5, end3, rel_end5, rel_end3, m_lend, m_rend, curated, " .
		  "date, assignby, change_log, save_history, method, " .
		  "per_id, per_sim, score, db, pvalue, domain_score, " .
		  "expect_domain, total_score, expect_whole, chainID) " .
		  "VALUES (?, ?, ?, ?, ?, -1, -1, ?, ?, 0, getdate(), " .
		  "'workflow', 0, 0, ?, ?, ?, ?, ?, NULL, ?, NULL, ?, " .
		  "NULL, ?)";
	return $dbh->prepare($sql);
}
